\chapter{Extensibility of GP}
\label{ch3:extensibility}

Traditional engineering design optimization tools (eg. TASOPT) implement
convergence loops that assume structure within a given design problem.
The 'bag of constraints' form of the GP means that constraints can be
added to the problem without
having to restructure the optimization formulation.

\section{Improving fidelity: Adding a simple engine model to the SimPleAC}
\label{s:engine}

The SimPleAC currently has an engine that weighs nothing and magically supplies
unlimited power. This is obviously unphysical, and requires refinement.

\subsection{Creating an engine submodel}

Before even thinking about modeling, we would like to leverage the object-oriented 
GPkit models to put the variables describing the engine into a submodel (currently only 
BSFC). We do this by creating a new class called \textbf{Engine} and creating a \textit{setup}
method that returns the constraints within it.

\begin{python}
class Engine(Model):
    def setup(self):
        # Dimensional constants
        BSFC      = Variable("BSFC", 400, "g/(kw*hr)", "brake specific fuel consumption")
        constraints = []
        return constraints    
\end{python}

We allow the SimPleAC model to contain the variables and constraints of the engine
as follows:

\begin{python}
class SimPleAC(Model):
    def setup(self):
        self.engine = Engine()
        self.components = [self.engine]
        # Env. constants
        ...
        return constraints, self.components
\end{python}

This restructuring of the model yields the exact same overall \gls{GP} formulation
as the unstructured problem, but gives us the flexibility to develop submodels
collaboratively and in a disciplined manner.

If we think of an engine as an input-output system, we can determine how it
would interact with the SimPleAC system, and create appropriately bounded
sets of variables.
At the most basic level, the engine provides shaft power, consumes fuel, 
and has weight. The model is missing both the shaft power and weight description
of the engine. If we abstract away the propeller (the relation between shaft
power and thrust power) through a propeller efficiency,
we can perhaps relate maximum power to weight.

\subsection{Data-based modeling: engine power vs. weight}
\label{s:datafit}

We can imagine that, for a specific kind of engine, there is a relation between the 
maximum shaft power available and the mass of the engine, somewhat related to the 
cube-square law, which describes the relation between the surface area and volume 
of objects. And let's assume that our knowledge of the internal workings of engines
is limited, but we have some knowledge of the technology available in the market
and have data to support it. Using GPfit, we will try to fit the data to find
\gls{GP} compatible relations between engine weight and maximum power. This section
will try to highlight the best practices when making data-based models. 

To be able to fit the engine power vs. weight data, we take several important steps.
\begin{itemize}
    \item \textbf{Comb the data.} Since we are essentially projecting
    data with potentially high standard deviation onto a single line,
    it is important to fit the ranges of data we care about.
    \item \textbf{Normalize the data.} Normalizing the data
	by some known quantity is preferable, since we would not want our fit to be dependent on the
	units that we used while performing it. This also helps the fit integrate
    seamlessly into GPkit, since dimensional fits would require units manipulation
    to avoid errors. The data can be normalized by any
    reference quantities (in this case using the maximum power and weight values
    from the data set).
    \item \textbf{Choose the type of fit.} In~\cite{gpfitpaper}, \textit{softmax-affine}
    (SMA) and \textit{implicit softmax-affine} (ISMA)
    functions are proposed as convex approximations
    to data. Depending on the behavior of the data, one or the other
    may be appropriate. For engineering relations that are expected to be smooth, SMA
    functions are often good approximations. However, if kinks are expected in the
    functions, ISMA functions can locally adjust the softness of the fit to
    reduce the error of the fit.
    \item \textbf{Choose the number of posynomial terms in the fit.} The number of
    terms will likely depend on the root-mean square (RMS) error of the fit, and
    the kind of pressure on the variable. RMS error can be reduced by including
    more posynomial terms, but only if the variable of interest has downward
    pressure on it from the objective function (since it is on the greater side
    of the inequality).
\end{itemize}

After having performed these intermediate steps on the engine data,
the relation we obtain for the one-term approximation is as follows:
\begin{equation}
	(\frac{W_{eng}}{W_{eng_{max}}})^{0.100} = 0.988 (\frac{P_{shaft}}{P_{shaft,max}})^{0.117}
\end{equation}

Note that the root mean square error of this fit is 0.414, but this has to do with 
the level of variation in the data. Since engine weight will have downward pressure
on it from the objective, we can easily use a two-term posynomial approximation to 
improve its error. 

\begin{equation}
	(\frac{W_{eng}}{W_{eng_{max}}})^{0.801} \geq 0.0330 (\frac{P_{shaft}}{P_{shaft,max}})^{0.167}
												+1.59 (\frac{P_{shaft}}{P_{shaft,max}})^{1.36}
\end{equation}

This relation has an r.m.s. error of 0.346, which is a significant improvement. 

It turns out that with a SMA approximation, more terms do not improve the r.m.s.
error of the fit on the given data. As such, we will proceed with the 2-term posynomial fit.

\subsubsection{Other constraints in engine model}

I constrain the cruise shaft power to be 20\% of the maximum shaft power of the engine,
to account for engine surge power demands.

\begin{equation}
    P_shaft \leq \frac{1}{5} P_{shaft,max}
\end{equation}

\subsection{Converting all subsystems into submodels}
\label{s:submodels}

Within this framework, we can modularize also add a separate wing and fuselage module to
SimPleAC as well, with very little additional work. This creates the variable and constraint
hierarchy as presented in Figure~\ref{forest:submodels}, which define all of the constraints
required for SimPleAC to fly one flight segment.

\begin{figure}[!h]\centering\small\sffamily
\begin{forest} sn edges
    [\textbf{Aircraft}
        [\textbf{Wing}]
        [\textbf{Fuselage}]
        [\textbf{Engine}]
    ]
\end{forest}
\caption{Variable and constraint hierarchy of the single mission segment SimPleAC model}
\label{forest:submodels}
\end{figure}

Tree structures such as in Figure~\ref{forest:submodels} are informative, since
it provides an intuitive representation of the way constraints and variables
are passed between GPkit models. The way the \gls{SP} is solved at the end has no
hierarchy, but as we will see in Section~\ref{s:mission} a hierarchical representation
will facilitate the vectorization of constraints required for mission design.

%TODO: develop on the idea of variable and constraint hierarchy

\section{Converting the SimPleAC to performance modeling form}
\label{s:mission}

The SimPleAC that I have defined so far works well to demonstrate the
capabilities of \gls{SP} in helping explore tradeoffs in engineering design.
However, often in the design process, we will want to test the performance of a
design in different conditions, and/or during different phases of a mission.
This requires the vectorization of
constraints that relate to the performance of the design. What we'd like to do
is to have a single aircraft optimize both its static sizing variables (having
to do with the airframe), and its flight performance simultaneously. This requires a major
augmentation of the model tree defined in Figure~\ref{forest:submodels}, into a
uni-directional graph as shown in Figure~\ref{f:missiongraph}.

\begin{figure}[!h]
    \centering\small\sffamily
    \begin{forest} sn edges,
    l sep+=1em,
    for children={
    l sep+=1em,
    }
    [\textit{\textbf{Mission}},name=mission
    [\textit{\textbf{\shortstack{Aircraft\\Perf.}}},name=aircraftP2
    [\textit{\shortstack{Wing\\Perf}},name=wingP2]
    [\textit{\shortstack{Engine\\Perf.}},name=engineP2
    [\textit{Atmosphere},name=atmos2]]]
    [,name=phantom
    [\textbf{Aircraft},name=aircraft
    [\textbf{Wing},name=wing]
    [\textbf{Fuselage},name=fuse]
    [\textbf{Engine},name=engine]
    ]]
    [\textit{\textbf{\shortstack{Aircraft\\Perf.}}},name=aircraftP1
    [\textit{\shortstack{Wing\\Perf}},name=wingP1]
    [\textit{\shortstack{Engine\\Perf.}},name=engineP1
    [\textit{Atmosphere},name=atmos1]]
    ]
    ]
        \draw[->] (atmos1) -- (wingP1);
        \draw[->] (atmos1) -- (aircraftP1);
        \draw[->] (atmos2) -- (wingP2);
        \draw[->] (atmos2) -- (aircraftP2);
        \draw[->] (aircraft) -- (aircraftP1);
        \draw[->] (aircraft) -- (aircraftP2);
        \draw[->] (wing) -- (wingP1);
        \draw[->] (engine) -- (engineP1);
        \draw[->] (wing) -- (wingP2);
        \draw[->] (engine) -- (engineP2);
        \node[draw,rectangle,fit={(aircraftP2) (atmos2) (engineP2) (wingP2)}] {};
        \node[draw,rectangle,fit={(aircraftP1) (atmos1) (engineP1) (wingP1)}] {};
    \end{forest}
    \caption{Variable and constraint hierarchy of the presented aircraft model, for two flight
    segments. Models that include sizing variables are
    bolded while models that include performance variables are italicized.
    There are models that contain both kinds of variables.}
    \label{f:missiongraph}
\end{figure}

The performance models are enclosed in a rectangle, and they are
vectorized by the number of flight segments, $N_{segments}$. Each
one of the performance models contain variables that change between flight segments.
Note that I have created a performance model for all subcomponents other than the
fuselage. This is because the only performance variable of the fuselage is its drag
coefficient, which is assumed to not change between flight segments, making it static. I
have also added a \textbf{Mission} model, which links flight segments together,
and an \textbf{Atmosphere} model, which describes the conditions in which the aircraft
operates.

The static aircraft model, and the atmospheric state are passed as an argument to multiple
performance models within this framework. To transform our previously static model to
the performance-static model hierarchy we have identified,
we have to determine which variables
belong in which level of the tree. Table~\ref{tab:missionvars} details the full
decomposition of the model into its submodels in the format defined
by Figure~\ref{f:missiongraph}. This is as simple as identifying which variables
we do not expect to change during flight segments, and which ones we do.

\begin{center}
\captionof{table}{Variables of SimPleAC in performance modeling, detailed in the
variable and constraint hierarchy.}
\input{tables/SimPleAC_missionvars.tex}
    \label{tab:missionvars}
\end{center}

Then, using the variable structure in Table~\ref{tab:missionvars}, we can place the
constraints in the appropriate locations. Each constraint should be placed
in the model that contains the variable in the constraint that is highest in the level of hierarchy. For example,
we can consider the constraint for thrust power in Equation~\ref{e:thrustConstr}.

\begin{equation}
    \label{e:thrustConstr}
T \times V \leq \eta_{prop} P_{shaft}
\end{equation}

We expect that thrust ($T$) and shaft power ($P_{shaft}$) occur
in \textit{Engine Performance}. Since our model has no model for propeller efficiency ($\eta_{prop}$), we treat it
as a static variable in \textbf{Engine}. And velocity ($V$) is a variable in \textbf{\textit{Aircraft {Performance}}}.
As a result, the constraint for thrust power would logically reside in the \textbf{\textit{Aircraft {Performance}}}
model, the highest level in the hierarchy as shown in Figure~\ref{f:thrustConstr}. Since this model is vectorized,
the constraint would be vectorized by the number of flight segments we create.

\begin{figure}[!h]\centering\small\sffamily
\begin{forest}
        [\textit{\textbf{Mission}},name=mission
            [\textit{\textbf{\shortstack{Aircraft\\Perf.}}},name=aircraftP
                [\textbf{Aircraft},name=aircraft
                    [\textbf{Wing},name=wing]
                    [\textbf{Fuselage},name=fuse]
                    [\textbf{Engine},name=engine]
                ]
                [\textit{\shortstack{Wing\\Perf}},name=wingP]
                [\textit{\shortstack{Engine\\Perf.}},name=engineP
                            [\textit{Atmosphere},name=atmos]]
            ]
        ]
        \draw[->] (atmos) -- (wingP);
        \draw[->] (atmos) -- (aircraftP);
        \draw[->] (aircraft) -- (aircraftP);
        \draw[->] (aircraft) -- (mission);
        \draw[->] (wing) -- (wingP);
        \draw[->] (engine) -- (engineP);
        \node[draw,rectangle,fit={(engineP)}] {};
        \node[draw,rectangle,fit={(aircraftP)}] {};
        \node[draw,rectangle,fit={(engine)}] {};
\end{forest}
   \caption{The models that contain the variables in Equation~\ref{e:thrustConstr} are enclosed in rectangles.
   Constraint logically resides in \textbf{\textit{Aircraft Perf.}}.
   Vectorized performance models have been removed for clarity.}
\label{f:thrustConstr}
\end{figure}

\subsection{Characterizing the environment: atmospheric model}

To design the mission for SimPleAC, we have to have a better understanding
of the environment in which the aircraft operates. So far, we have assumed that
the aircraft flies at a constant altitude (sea level) for a single mission segment,
and is subject to the same air density and viscosity.

\subsection{Engine lapse rate model}

\subsection{Making use of sensitivities: engine BSFC model}

\subsection{Design exploration through mission design}

Mission design often exploits the weaknesses of existing models to arrive at solutions
that do not seem physical. In this
specific modeling example, it shows the weaknesses of the engine model.


The first weakness is the fact that the engine can supply the same amount of power
regardless of altitude. \gls{GP} can help us observe this behavior by allowing engineers to
evaluate a number of optimal designs quickly, and enabling the observation of trends.
For naturally aspirated piston engines, we would expect the maximum power available to
drop with altitude; adding such a lapse rate will improve the fidelity of the engine.

THe second is the lack of

\section{Multimission design}

Having created a mission profile for the SimPleAC, it only takes one extra level of
hierarchy to do multimission design. Now we vectorize the performance
and atmosphere models that are flown by the same aircraft.



\chapter{Extensibility of GP}
\label{ch3:extensibility}

Traditional engineering design optimization tools (eg. TASOPT) implement
convergence loops that assume structure within a given design problem.
The 'bag of constraints' form of the GP means that constraints can be
added to the problem without
having to restructure the optimization formulation.

\section{Examining results: SimPleAC solution and sensitivities}

%TODO: insert solutions and sensitivities tables, and show
%TODO: why we have to have an engine model

\section{Improving fidelity: Adding a simple engine model to the SimPleAC}
\label{s:engine}

The SimPleAC currently has an engine that weighs nothing and magically supplies
unlimited power. This is obviously unphysical, and since one of the variables
with the highest sensitivity is \BSFC, requires refinement.

\subsection{Creating an engine submodel}

Before even thinking about modeling, we would like to leverage the object-oriented 
GPkit models to put the variables describing the engine into a submodel (currently only 
BSFC). We do this by creating a new class called \textbf{Engine} and creating a \textit{setup}
method that returns the constraints within it.

\begin{python}
class Engine(Model):
    def setup(self):
        # Dimensional constants
        BSFC      = Variable("BSFC", 400, "g/(kw*hr)", "brake specific fuel consumption")
        constraints = []
        return constraints    
\end{python}

We allow the SimPleAC model to contain the variables and constraints of the engine
as follows:

\begin{python}
class SimPleAC(Model):
    def setup(self):
        self.engine = Engine()
        self.components = [self.engine]
        # Env. constants
        ...
        return constraints, self.components
\end{python}

This restructuring of the model yields the exact same overall \gls{GP} formulation
as the unstructured problem, but gives us the flexibility to develop submodels
collaboratively and in a disciplined manner.

If we think of an engine as an input-output system, we can determine how it
would interact with the SimPleAC system, and create appropriately bounded
sets of variables.
At the most basic level, the engine provides shaft power, consumes fuel, 
and has weight. The model is missing both the shaft power and weight description
of the engine. If we abstract away the propeller (the relation between shaft
power and thrust power) through a propeller efficiency,
we can perhaps related maximum power to weight.

\subsection{Data-based modeling: engine power vs. weight}
\label{s:datafit}

We can imagine that, for a specific kind of engine, there is a relation between the 
maximum shaft power available and the mass of the engine, somewhat related to the 
cube-square law, which describes the relation between the surface area and volume 
of objects. And let's assume that our knowledge of the internal workings of engines
is limited, but we have some knowledge of the technology available in the market
and have data to support it. Using GPfit, we will try to fit the data to find
\gls{GP} compatible relations between engine weight and maximum power. This section
will try to highlight the best practices when making data-based models. 

To be able to fit the engine power vs. weight data, we take several important steps.
\begin{itemize}
    \item \textbf{Comb the data.} Since we are essentially projecting
    data with potentially high standard deviation into a single line,
    it is important to fit the ranges of data we care about.
    \item \textbf{Normalize the data.} Normalizing the data
	by some known quantity is preferable, since we would not want our fit to be dependent on the
	units that we used while performing it. This also helps the fit integrate
    seamlessly into GPkit, since dimensional fits would require units manipulation
    to avoid errors. The data can be normalized by any
    reference quantities (in this case using the maximum power and weight values
    from the data set).
    \item \textbf{Choose the type of fit.} In~\cite{gpfitpaper}, \textit{softmax-affine}
    (SMA) and \textit{implicit softmax-affine} (ISMA)
    functions are proposed as convex approximations
    to data. Depending on the behavior of the data, one or the other
    may be appropriate. For engineering relations that are expected to be smooth, SMA
    functions are often good approximations. However, if kinks are expected in the
    functions, ISMA functions can locally adjust the softness of the fit to
    reduce the error of the fit.
    \item \textbf{Choose the number of posynomial terms in the fit.} The number of
    terms will likely depend on the root-mean square (RMS) error of the fit, and
    the kind of pressure on the variable. RMS error can be reduced by including
    more posynomial terms, but only if the variable of interest has downward
    pressure on it from the objective function (since it is on the greater side
    of the inequality).
\end{itemize}

After having performed these intermediate steps on the engine data,
the relation we obtain for the one-term approximation is as follows:
\begin{equation}
	(\frac{W_{eng}}{W_{eng_{max}}})^{0.100} = 0.988 (\frac{P_{shaft}}{P_{shaft,max}})^{0.117}
\end{equation}

Note that the root mean square error of this fit is 0.414, but this has to do with 
the level of variation in the data. Since engine weight will have downward pressure
on it from the objective, we can easily use a two-term posynomial approximation to 
improve its error. 

\begin{equation}
	(\frac{W_{eng}}{W_{eng_{max}}})^{0.801} \geq 0.0330 (\frac{P_{shaft}}{P_{shaft,max}})^{0.167}
												+1.59 (\frac{P_{shaft}}{P_{shaft,max}})^{1.36}
\end{equation}

This relation has an r.m.s. error of 0.346, which is a significant improvement. 

It turns out that with a SMA approximation, more terms do not improve the r.m.s.
error of the fit on the given data. As such, we will proceed with the 2-term posynomial fit.

\subsubsection{Other constraints in engine model}

I constrain the cruise shaft power to be 20\% of the maximum shaft power of the engine,
to account for engine surge power demands, and the

\subsection{Converting all subsystems into submodels}
\label{s:submodels}

Within this framework, we can modularize also add a separate wing and fuselage module to
SimPleAC as well, with very little additional work. This creates the variable and constraint
hierarchy as presented in Figure~\ref{forest:submodels}, which define all of the constraints
required for SimPleAC to fly one flight segment.

\begin{figure}[!h]\centering\small\sffamily
\begin{forest}
    [\textbf{Aircraft}
        [\textbf{Wing}]
        [\textbf{Fuselage}]
        [\textbf{Engine}]
    ]
\end{forest}
\caption{Variable and constraint hierarchy of the single mission segment SimPleAC model}
\label{forest:submodels}
\end{figure}

Tree structures such as in Figure~\ref{forest:submodels} are informative, since
it provides an intuitive representation of the way constraints and variables
are passed between GPkit models. The way the \gls{GP} is solved at the end has no
hierarchy.

%TODO: develop on the idea of variable and constraint hierarchy

\section{Designing missions: Converting the SimPleAC to performance modeling form}
\label{s:mission}

The SimPleAC that I have defined so far works well to demonstrate the
capabilities of \gls{SP} in helping explore tradeoffs in engineering design.
However, often in the design process, we will want to test the performance of a
design in different conditions. This requires the vectorization of
constraints that relate to the performance of the design.

To design the mission for SimPleAC, we have to have a better understanding
of the environment in which the aircraft operates. So far, we have assumed that
the aircraft flies at a constant altitude (sea level) for a single mission segment,
and is subject to the same air density and viscosity. What we'd like to do instead
is to have a single aircraft optimize both its static sizing variables (having
to do with the airframe), and its flight performance. This requires a major
augmentation of the model tree defined in Figure~\ref{forest:submodels}.

\begin{figure}[!h]\centering\small\sffamily
\begin{forest}
        [\textit{\textbf{Mission}}
            [\textit{Atmosphere}]
            [\textit{\textbf{\shortstack{Aircraft\\Perf.}}}
                [\textbf{Aircraft}
                    [\textbf{Wing}]
                    [\textbf{Fuselage}]
                    [\textbf{Engine}]
                ]
                [\textit{\shortstack{Wing\\Perf}}]
                [\textit{\shortstack{Engine\\Perf.}}]
            ]
        ]
\end{forest}
   \caption{Variable and constraint hierarchy of the presented aircraft model. Models that include sizing variables are
bolded while models that include performance variables are italicized.
There are models that contain both kinds of variables.}
\label{f:componenttree}
\end{figure}

Note that I have created a performance model for all subcomponents other than the
fuselage. This is because the only performance variable of the fuselage is its drag
coefficient, which is assumed to not change between flight segments, making it static.

The aircraft model that is passed as an argument to the separate flight segments is the
same static aircraft model. %TODO: improve this explanation.

Within the model hierarchy we have identified, we have to determine which variables
belong in which level of the tree. Table~\ref{tab:missionvars} details the full
decomposition of the model into its submodels in the format defined
by Figure~\ref{f:componenttree}.

\begin{center}
\captionof{table}{Variables of SimPleAC in performance modeling, detailed in the
variable and constraint hierarchy.}
\input{tables/SimPleAC_missionvars.tex}
    \label{tab:missionvars}
\end{center}

\section{Multimission design}

Having created a mission profile for the SimPleAC, it only takes one extra level of
hierarchy to do multimission design. Now we vectorize the performance
and atmosphere models that are flown by the same aircraft.

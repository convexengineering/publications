\chapter{Extensibility of GP}

Traditional engineering design optimization tools (eg. TASOPT) implement
convergence loops that assume structure within a given design problem.
The 'bag of constraints' form of the GP means that constraints can be
added to the problem without
having to restructure the optimization formulation.

\section{Improving fidelity: Adding a simple engine model to the SimPleAC}
\label{s:engine}

The SimPleAC currently has an engine that weighs nothing and magically supplies
unlimited power. This is obviously unphysical, and since one of the variables
with the highest sensitivity is \TSFC, requires refinement.

\subsection{Creating an engine submodel}

Before even thinking about modeling, we would like to leverage the object-oriented 
GPkit models to put the variables describing the engine into a submodel (currently only 
TSFC). We do this by creating a new class called \textbf{Engine} and creating a \textit{setup}
method that returns the constraints within it.

\begin{python}
class Engine(Model):
    def setup(self):
        # Dimensional constants
        TSFC      = Variable("TSFC", 0.6, "1/hr", "thrust specific fuel consumption")
        constraints = []
        return constraints    
\end{python}

We allow the SimPleAC model to contain the variables and constraints of the engine
as follows:

\begin{python}
class SimPleAC(Model):
    def setup(self):
        self.engine = Engine()
        self.components = [self.engine]
        # Env. constants
        ...
        return constraints, self.components
\end{python}

This restructuring of the model yields the exact same overall GP formulation 
as the unstructured problem, but gives us the flexibility to develop submodels
collaboratively and in a disciplined manner.

If we think of an engine as an input-output system, we can determine how it
would interact with the SimPleAC system, and create the appropriate variables. 
At the most basic level, the engine provides shaft power, consumes fuel, 
and has weight. The model is missing both the shaft power and weight description
of the engine. If we abstract away the propeller (the relation between shaft
power and thrust power) for the moment, we can perhaps find a way to relate
power to weight

\subsection{Data-based modeling: engine power vs. weight}
\label{s:datafit}

We can imagine that, for a specific kind of engine, there is a relation between the 
maximum shaft power available and the mass of the engine, somewhat related to the 
cube-square law, which describes the relation between the surface area and volume 
of objects. And let's say that our knowledge of the internal workings of engines
is limited, but we have some knowledge of the technology available in the market
and have data to support it. Using GPfit, we will try to fit the data to find
\gls{GP} compatible relations between engine weight and maximum power. This section
will try to highlight the best practices when making data-based models. 

To be able to fit the engine power vs. weight data, we take several important steps.
\begin{itemize}
    \item \textbf{Comb the data.} Since we are essentially projecting
    data with potentially high standard deviation into a single line,
    it is important to fit the ranges of data we care about.
    \item \textbf{Normalize the data.} It is very important to normalize the data
	by some known quantity, since we would not want our fit to be dependent on the
	units that we used while performing it. This also helps the fit integrate
    seamlessly into GPkit, since dimensional fits would require units manipulation
    to avoid errors. The data can be normalized by any
    reference quantities (in this case using the maximum power and weight values
    from the data set).
    \item \textbf{Choose the type of fit.} In~\cite{gpfitpaper}, \textit{softmax-affine}
    (SMA) and \textit{implicit softmax-affine} (ISMA)
    functions are proposed as convex approximations
    to data. Depending on the behavior of the data, one or the other
    may be appropriate. For engineering relations that are expected to be smooth, SMA
    functions are often good approximations. However, if kinks are expected in the
    functions, ISMA functions can locally adjust the softness of the fit to
    reduce the error of the fit.
    \item \textbf{Choose the number of posynomial terms in the fit.} The number of
    terms will likely depend on the root-mean square (RMS) error of the fit, and
    the kind of pressure on the variable. RMS error can be reduced by including
    more posynomial terms, but only if the variable of interest has downward
    pressure on it from the objective function (since it is on the greater side
    of the inequality).
\end{itemize}


The relation we obtain for the one-term approximation is as follows:
\begin{equation}
	(\frac{W_{eng}}{W_{eng_{max}}})^{0.100} = 0.988 (\frac{P_{shaft}}{P_{shaft_{max}}})^{0.117}
\end{equation}

Note that the root mean square error of this fit is 0.414, but this has to do with 
the level of variation in the data. Since engine weight will have downward pressure
on it from the objective, we can easily use a two-term posynomial approximation to 
improve its error. 

\begin{equation}
	(\frac{W_{eng}}{W_{eng_{max}}})^{0.801} \geq 0.0330 (\frac{P_{shaft}}{P_{shaft_{max}}})^{0.167} 
												+1.59 (\frac{P_{shaft}}{P_{shaft_{max}}})^{1.36}
\end{equation}

This relation has an r.m.s. error of 0.346, which is a significant improvement. 

It turns out that with a softmax affine approximation, more terms do not improve the r.m.s.
error of the fit on the given data. As such, we will proceed with the 2-term posynomial fit. 

\subsection{Converting all subsystems into submodels}
\label{s:submodels}

Within this framework, we can modularize also add a separate wing and fuselage module to
SimPleAC as well, with very little additional work. This creates the variable and constraint
hierarchy as presented in Figure~\ref{forest:submodels}

\begin{figure}[!h]\centering\small\sffamily
\begin{forest}
    [\textbf{Aircraft}
        [\textbf{Wing}]
        [\textbf{Fuselage}]
        [\textbf{Engine}]
    ]
\end{forest}
\label{forest:submodels}
\end{figure}

\section{Expanding scope: Converting the SimPleAC to performance modeling form}

The SimPleAC that I have defined so far works well to demonstrate the
capabilities of \gls{SP} in helping explore tradeoffs in engineering design.

However, often in the design process, we will want to test the performance of a
design in different flight conditions. This requires the vectorization of 
constraints that relate to the performance of the design.

\begin{figure}[!h]\centering\small\sffamily
\begin{forest}
        [\textit{\textbf{Mission}}
            [\textit{Mission Profile}]
            [\textit{Atmosphere}]
            [\textit{\textbf{\shortstack{Aircraft\\Perf.}}}
                [\textbf{Aircraft}
                    [\textbf{Wing}]
                    [\textbf{Fuselage}]
                    [\textbf{Engine}]
                ]
                [\textit{\shortstack{Wing\\Perf}}]
                [\textit{\shortstack{Fuselage\\Perf.}}]
                [\textit{\shortstack{Engine\\Perf.}}]
            ]
        ]
    \end{forest}
    \caption{Variable and constraint hierarchy of the presented aircraft model. Models that include sizing variables are
bolded while models that include performance variables are italicized.
There are models that contain both kinds of variables.}
\label{f:componenttree}
\end{figure}

\section{Creating a mission}

Having transformed the models into performance form

\section{Multimission design}

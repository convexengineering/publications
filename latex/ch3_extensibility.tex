\chapter{Extensibility of GP}

Traditional engineering design optimization tools (eg. TASOPT) implement convergence loops that assume structure within a given design problem. 

The 'bag of constraints' form of the GP means that constraints can be added to the problem without 
having to restructure the optimization formulation. 

\section{Improving fidelity: Adding a simple engine model to the SimPleAC}
\label{sec:engine}

The SimPleAC currently has an engine that weighs nothing and magically supplies
unlimited power. This is obviously unphysical, and since one of the variables
with the highest sensitivity is \TSFC, requires refinement.

\subsection{Creating an engine submodel}

Before even thinking about modeling, we would like to leverage the object-oriented 
GPkit models to put the variables describing the engine into a submodel (currently only 
TSFC). We do this by creating a new class called \textbf{Engine} and creating a \textit{setup}
method with the 

\begin{python}
class Engine(Model):
    def setup(self):
        # Dimensional constants
        TSFC      = Variable("TSFC", 0.6, "1/hr", "thrust specific fuel consumption")
        constraints = []
        return constraints    
\end{python}

We allow the SimPleAC model to contain the variables and constraints of the engine
as follows:

\begin{python}
class SimPleAC(Model):
    def setup(self):
        self.engine = Engine()
        # Env. constants
        ...
\end{python}

This restructuring of the model yields the exact same overall GP formulation 
as the unstructured problem, but gives us the flexibility to develop submodels
collaboratively in a disciplined manner.  

If we think of an engine as an input-output system, we can determine how it
would interact with the SimPleAC system, and create the appropriate variables. 
At the most basic level, the engine provides shaft power, consumes fuel, 
and has weight. The model is missing both the shaft power and weight description
of the engine, if we abstract away the propeller, which converts the shaft power 
to thrust power. 

\subsection{Data-based modeling: engine power vs. weight}
\label{sec:datafit}

We can imagine that, for a specific kind of engine, there is a relation between the 
maximum shaft power available and the mass of the engine, somewhat related to the 
cube-square law, which describes the relation between the surface area and volume 
of objects. And let's say that our knowledge of the internal workings of engines
is limited, but we have some knowledge of the technology available in the market
and have data to support it. Using GPfit, we will try to fit the data to find
GP compatible relations between engine weight and maximum power. This section 
will try to highlight the best practices when making data-based models. 

To be able to fit the engine power vs. weight data

\begin{itemize}
	\item \textbf{Normalize the data.} It is very important to normalize the data
	by some known quantity, since we would not want our fit to be dependent on the 
	units that we had on our points while performing it. 
\end{itemize}


The relation we obtain for the one-term approximation is as follows:
\begin{equation}
	(\frac{W_{eng}}{W_{eng_{max}}})^{0.100} = 0.988 (\frac{P_{shaft}}{P_{shaft_{max}}})^{0.117}
\end{equation}

Note that the root mean square error of this fit is 0.414, but this has to do with 
the level of variation in the data. Since engine weight will have downward pressure
on it from the objective, we can easily use a two-term posynomial approximation to 
improve its error. 

\begin{equation}
	(\frac{W_{eng}}{W_{eng_{max}}})^{0.801} \geq 0.0330 (\frac{P_{shaft}}{P_{shaft_{max}}})^{0.167} 
												+1.59 (\frac{P_{shaft}}{P_{shaft_{max}}})^{1.36}
\end{equation}

This relation has an r.m.s. error of 0.346, which is a significant improvement. 

It turns out that with a softmax affine approximation, more terms do not improve the r.m.s.
error of the fit on the given data. As such, we will proceed with the 2-term posynomial fit. 




\subsection{Converting all subsystems into submodels}

Within this framework, we can modularize also add a separate wing and fuselage module to
SimPleAC as well

\section{Expanding scope: Converting the SimPleAC to performance modeling form}

The SimPleAC that I have defined so far works well to demonstrate the
capabilities of \gls{SP} in helping explore tradeoffs in engineering design.

However, often in the design process, we will want to test the performance of a
design in different flight conditions. This requires the vectorization of 
constraints that relate to the performance of the design. 
